package org.itmo;

import java.util.*;
import java.util.concurrent.ConcurrentLinkedQueue;
import java.util.concurrent.ExecutionException;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.Future;
import java.util.concurrent.atomic.AtomicBoolean;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.stream.Collectors;
import java.util.stream.Stream;

import lombok.extern.slf4j.Slf4j;

@Slf4j
class Graph {
    private final int V;
    private final ArrayList<Integer>[] adjList;

    private static final int CORES_NUM = 28;

    private final ExecutorService executorService = Executors.newFixedThreadPool(CORES_NUM);

    Graph(int vertices) {
        this.V = vertices;
        adjList = new ArrayList[vertices];
        for (int i = 0; i < vertices; ++i) {
            adjList[i] = new ArrayList<>();
        }
    }

    void addEdge(int src, int dest) {
        if (!adjList[src].contains(dest)) {
            adjList[src].add(dest);
        }
    }

    List<Integer> childrenOf(int vertex) {
        return adjList[vertex];
    }

    void parallelBFS(int startVertex) throws InterruptedException, ExecutionException {
        AtomicBoolean[] visited = new AtomicBoolean[V];
        for (int i = 0; i < V; ++i) {
            visited[i] = new AtomicBoolean(false);
        }

        AtomicInteger nextQueueIdx = new AtomicInteger(0);

        Queue<Integer>[] queues = new Queue[1];
        queues[0] = new ConcurrentLinkedQueue<>();

        visited[startVertex].set(true);
        queues[0].add(startVertex);

        while (true) {
            Queue<Integer>[] nextQueueLayer = new Queue[CORES_NUM];
            for (int i = 0; i < CORES_NUM; ++i) {
                nextQueueLayer[i] = new ConcurrentLinkedQueue<>();
            }

            List<Future<Void>> futures = Stream.of(queues)
                    .filter(queue -> !queue.isEmpty())
                    .map(queue -> executorService.submit(() -> handleQueue(queue, visited, nextQueueLayer, nextQueueIdx)))
                    .collect(Collectors.toList());

            if (futures.isEmpty()) {
                break;
            }

            for (Future<Void> future : futures) {
                future.get();
            }

            queues = nextQueueLayer;
        }

        long visitedNum = Stream.of(visited).filter(AtomicBoolean::get).count();

        log.info("Visited {}/{} vertices", visitedNum, V);
        log.info("Visit count: {}", nextQueueIdx.incrementAndGet());
    }

    Void handleQueue(Queue<Integer> vertices, AtomicBoolean[] visited, Queue<Integer>[] queues, AtomicInteger nextQueue) {
        vertices.stream().forEach(startVertex -> {
            for (int vertex : adjList[startVertex]) {
                if (!visited[vertex].compareAndSet(false, true)) {
                    continue;
                }

                int selectedQueue = nextQueue.incrementAndGet() % CORES_NUM;
                queues[selectedQueue].add(vertex);
            }
        });

        return null;
    }

    // Generated by ChatGPT
    void bfs(int startVertex) {
        boolean[] visited = new boolean[V];

        LinkedList<Integer> queue = new LinkedList<>();

        visited[startVertex] = true;
        queue.add(startVertex);

        while (!queue.isEmpty()) {
            startVertex = queue.poll();

            for (int n : adjList[startVertex]) {
                if (!visited[n]) {
                    visited[n] = true;
                    queue.add(n);
                }
            }
        }
    }

}
